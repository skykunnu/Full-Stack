<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object</title>
</head>
<body>
    
    <script>


// Objects is a collection of key and pairs

// Ways of accessing properties of Objects


// let person = {
//         name: "Shikhar",
//         phone: 1234512345,
//         age: 24,
//       };

/* 
1) Dot Notation:- 
document.write(person.name) // Shikhar


2) Bracket(Array) Notation:- 
document.write(person[age]) // 24

*/

// document.write(person); // Objects cannot be printed using document.write.

//-------------------------------------------------------------------------------------------------

// Object.keys() -> returns key of the object in a form of an array. 

// const object1 = {
//   a: 'somestring',
//   b: 42,
//   c: false,
// };

// console.log(Object.keys(object1)); // [a, b, c]



// Object.values() -> returns value of the object in a form of an array.

// console.log(Object.values(object1)) // ['somestring', 42, false]

// Write a loop using Object.keys( ) to log each key in the book object. 


// const books={
//     title: '1984',
//     author: 'George Orwell',
//     year: 1949
// }

// const keys=Object.keys(books); // ['title' ,'author', 'year']

// keys.forEach((Keybook)=>{   
//     console.log(Keybook);
// })


//--------------------------------------------------------------------

// Write a line of code using Object.values() to calculate the sum of all scores. 

// const scores={
//     math:90,
//     science:85,
//     history:88
// };


// const value=Object.values(scores); // [90, 85, 88]

// let sum=0;
// value.forEach((ScoreValue)=>{
// sum=sum+ScoreValue;
// })
// console.log(sum) // 263


// // Using reduce method
// const total=value.reduce((acc,num)=>{
// return acc+num;
// },0)
// console.log(total) // 263


// ----------------------------------------------------------------------

// Write a line of code to reverse the properties of object using for loop and object methods only. 

// const person={
//     name:"Shikhar",
//     Age:24,
//     Position:"SDE"
// }

// const Reversekeys=Object.keys(person).reverse(); 

// const ReverseValues=Object.values(person).reverse();


// const reversedFruits={}

// using for loop

// for(let i=0;i<Reversekeys.length;i++){
//     // reversedFruits[keys[i]] -> Read as reversedFruits.keys[i], keys[2]=Position and so on. 
//     reversedFruits[Reversekeys[i]] =ReverseValues[i]  
// }
// console.log(reversedFruits)


// --------------------------------------------------------------------------------------------------

// Object.enteries() -> returns an array of a given object's own string-keyed property key-value pairs. 


// const object1 = {
//   a: 'somestring',
//   b: 42,
// };

// for (const [key, value] of Object.entries(object1)) {
//   console.log(`${key}: ${value}`);
// }
// a :'somestring'
// b: 42


// -----------------------------------------------------------------------------------------------------------------------------------

//  Object.seal() -> It seals an object means existing properties cannot be removed , new properties cannot be added but the values of existing properties can be changed.

// const object1 = {
//   property1: 42,
// };

// Object.seal(object1);
// object1.property1 = 33;
// console.log(object1.property1); // 33
 
// delete object1.property1; // existing properties cannot be removed. 
// console.log(object1.property1); // 33

// ------------------------------------------------------------------------------------------------------------------------------------

// Object.freeze() -> It freezes an object means all the properties of seal() including values of properties cannot be changed. 



// const obj = {
//   prop: 42,
// };

// Object.freeze(obj);

// obj.prop = 33;

// console.log(obj.prop); // 42


// -------------------------------------------------------------------------------------------------------------------------------------

// Object.assign() -> copies all properties from one or more source objects to a target object. It returns the modified target object.

// const target = { a: 1, b: 2 };
// const source = { b: 4, c: 5 };

// const returnedTarget = Object.assign(target, source);

// console.log(target);
// // Expected output: Object { a: 1, b: 4, c: 5 } (b:4 becoz priority of b:4 is more than b:2)


// -----------------------------------------------------------------------------------------------------------------------------------------
const names = [
        "Ranveer",
        "Harendra",
        "Sonu",
        "Lucky",
        "Pankaj",
        "Anant",
        "Rishabh",
        "Shikhar",
        "Sunil",
      ];

    //   inside anonymous function this is defined, and points to the caller
    //   where as, inside arrow function, this is not defined

    // ALl arrow functions are anonymous functions but vice versa is not true. Ex->  storing anonymous function inside a variable.
    
    

    //   const person = {
    //     name: "Rohit",
    //     age: 33,
    //     profession: "Full Stack Developer",
    //     isMarried: true,
    //     skills: ["HTML", "CSS"], // array
    //     work: {     // nested object. 
    //       company: "Full Stack Learning",
    //       designation: "Owner",
    //     },
    //     getIntroduction: function () { // anonymous sfunction
    //       return "My name is " + this.name;
    //     },
    //   };

    //   console.log(names);

    //   for(let i=0;i<person.length)

    //   person.forEach((value) => {
    //     document.write(value);
    //   });


    //   document.write(person.getIntroduction());

    //   for (let i in person) {
    //     if (typeof person[i] === "object" && !person[i].length) {
    //       for (let j in person[i]) {
    //         document.write(i + "_" + j + ":" + person[i][j] + "<br>");
    //       }
    //     } else document.write(i + ":" + person[i] + "<br>");
    //   }

      
    //   const person = {
    //     name: "Rohit",
    //     age: 33,
    //     profession: "Full Stack Developer",
    //     isMarried: true,
    //     skills: ["HTML", "CSS"],
    //     work: {
    //       company: "Full Stack Learning",
    //       designation: "Owner",
    //     },
    //     getIntroduction: function () {
    //       return "My name is " + this.name;
    //     },
    //   };


    //   const a = person.name;
    //   console.log(a) // Rohit

    //   const a = person.getIntroduction.bind(person);
    //   console.log(a()); // My name is Rohit. 

    // const a=person.getIntroduction.call(person)  
    // console.log(a) // My name is Rohit. 


// -------------------------------------------------------------------------------------------------------------------------

//call, bind, apply -> These are the methods that allow you to control the value of this in functions.

// In JavaScript, call() is like you giving instructions to a function right away, saying, "Run this function, but use this person (or object) as this when running."


// const person = 
// { name: "Shikhar" ,
// sayHello: function(age,country){
// return `My name is ${this.name} and I am ${age} years old and I am from ${country}.`;
// }    
// };

// const a=person.sayHello.call(person,"24","India")
// console.log(a)

// The apply() method works similarly to call(), but instead of passing arguments individually, it accepts a single array of arguments. This is useful when you don’t know in advance how many arguments will be passed.



// const person = 
// { name: "Alice" ,
// sayHello: function(age,country){
// return `My name is ${this.name} and I am ${age} years old and I belong to ${country}`;
// }    
// };

// const a=person.sayHello.apply(person, [25, "USA"]);
// console.log(a)



// bind()-> This method doesn’t immediately invoke the function. Instead, it returns a new function that, when called, has (this) permanently set to the value provided. basically an object can borrow a method from another object.



// const person = 
// { name: "Alice",
// sayHello:function(age, country) {
//     console.log(`My name is ${this.name}, I am ${age} years old and from ${country}.`);
// }
//  };


// const boundSayHello = person.sayHello.bind(person,25,"USA");

// boundSayHello(); // My name is Alice, I am 25 years old and from USA. 


// ------------------------------------------------------------------------------------------------------------

// nested objects flatten by using recursion and without recursion.

// const person = {
//         name: "Shikhar",
//         address: {
//           city: "Jaipur",
//           village: "Sheher",
//         },
//         details: {
//           job: {
//             designation: "Full Stack Developer",
//             skills: {
//               frontend: "HTML, CSS, Js, React",
//               backend: "Node, Express",
//             },
//           },
//         },
//       };

//       for(let i in person){ 
//         if(typeof person[i]==="object"){  // typeof checking of name, address, details. 
//             for(let j in person[i]){  
//                if(typeof person[i][j]==='object'){ // typeof checking of address_city, address_village, details_job.
//                    for(let k in person[i][j]){
//                     if(typeof person[i][j][k]==='object'){ // typeof checking of details_job_designation & details_job_skills.
//                         for(let l in person[i][j][k]){
//                             if(typeof person[i][j][k][l]==='object'){}  // typeof checking of details_job_skills_frontend & details_job_skills_backend.
//                             else{
//                                 document.write(i+"_"+j+"_"+k+"_"+l+":"+person[i][j][k][l]+"<br>")
//                         }
//                         }
//                     }
//                     else{
//                         document.write(i+"_"+j+"_"+k+":"+person[i][j][k]+"<br>")
//                     }
//                    }
//                }
//                else{
//                 document.write(i + "_"+j +":"+ person[i][j]+"<br>")
//                }
//             }
//         }
//         else{
//             document.write(i+":"+person[i]+"<br>")
//         }
//       }







// Using Recursion. 



// const person = {
//         name: "Shikhar",
//         address: {
//           city: "Jaipur",
//           village: "Sheher",
//         },
//         details: {
//           job: {
//             designation: "Full Stack Developer",
//             skills: {
//               frontend: "HTML, CSS, JS",
//               backend: "Node, Express",
//             },
//           },
//         },
//       };

//        function flattenObjectRecursive(obj,extra=null){ // extra=null, becoz to handle the condn of keys having values other than object. 
//            for(let i in obj){
//             if(typeof obj[i]==="object"){ // 
//                flattenObjectRecursive(obj[i],i);} 
//             else{
//                 if(!extra) document.write(i+":"+obj[i]+"<br>") // this will work for keys having values other than objects. 
//                 else document.write(extra+"_"+i+":"+obj[i]+"<br>") // this will work for keys having values as objects
//             }
//            }
//        }

//        flattenObjectRecursive(person)




    </script>
</body>
</html>